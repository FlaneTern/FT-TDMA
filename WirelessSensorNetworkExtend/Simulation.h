#pragma once
#include "Distribution.h"
#include "SensorNode.h"

namespace WSN
{

	/// <summary>
	/// Sensor node state at a certain time interval
	/// </summary>
	struct SimulationInterval
	{
		WorkingState State;
		double StartTime;
		double EndTime;
	};

	/// <summary>
	/// The result of simulating the markov model on a pre-generated failure timings
	/// </summary>
	struct SimulationResultData
	{
		double Delta = 0;
		double CollectionTime = 0;
		double WastedTime = 0;
		double ActualTotalDuration = 0;
		uint64_t FinalFailureIndex = 0;

		std::vector<SimulationInterval> SimulationIntervals;

	};

	/// <summary>
	/// The failure timings generated by the coressponding Distribution. Also contains the result of simulating the markov model (SimulationResultData)
	/// </summary>
	struct SimulationDistributionData
	{
		std::vector<double> FailureTimestamps;
		std::vector<SimulationResultData> SRD;
	};

	/// <summary>
	/// Simulation hyperparameters
	/// </summary>
	struct SimulationParameters
	{
		double TotalDurationToBeTransferred = -1;
		double TransferTime = -1;
		double RecoveryTime = -1;


		/// <summary>
		/// Distributions for generating sensor nodes' locations. These should be normal distributions, it doesn't make sense to use any other distributions
		/// </summary>
		struct
		{
			Distribution X;
			Distribution Y;
		} m_SensorNodeLocationDistribution;
	};


	/// <summary>
	/// Constructs a simulation environment. Then, repeats simulation for all failures generated by distributions in m_Distributions
	/// </summary>
	class Simulation
	{
	public:
		Simulation(SimulationParameters sp);

		/// <summary>
		/// Adds a distribution to generate the failure timings
		/// </summary>
		/// <param name="dist">The distribution to be added</param>
		inline void AddFailureDistribution(Distribution dist) { m_FailureDistributions.push_back(dist); }

		/// <summary>
		/// Runs the simulation. Be sure to add the desired failure distributions using AddFailureDistribution() before running!
		/// </summary>
		void Run();

		double GetDeltaOpt();

		inline uint64_t GetSimulationID() const { return m_SimulationID; }
		inline SimulationParameters GetSimulationParameters() const { return m_SimulationParameters; }
		inline const std::vector<Distribution>& GetFailureDistributions() const { return m_FailureDistributions; }
		inline const std::vector<SimulationDistributionData>& GetSimulationDistributionDatas() const { return m_SimulationDistributionDatas; }

	private:

		uint64_t m_SimulationID;

		//static std::vector<SimulationSummaryData> s_Summary;

		SimulationParameters m_SimulationParameters;

		std::vector<SensorNode> m_SensorNodes;

		/// <summary>
		/// Distributions for generating failures
		/// </summary>
		std::vector<Distribution> m_FailureDistributions;

		/// <summary>
		/// Data specific to failures generated with the corresponding distribuion
		/// </summary>
		std::vector<SimulationDistributionData> m_SimulationDistributionDatas;

	};
}